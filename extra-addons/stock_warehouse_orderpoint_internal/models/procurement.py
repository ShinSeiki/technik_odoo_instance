# -*- coding: utf-8 -*-

from collections import defaultdict
from psycopg2 import OperationalError

from odoo import api, models, registry, _
from odoo.tools import DEFAULT_SERVER_DATETIME_FORMAT, float_compare, float_round

import logging

_logger = logging.getLogger(__name__)

class ProcurementOrder(models.Model):
    _inherit = "procurement.order"

    @api.model
    def _procure_orderpoint_confirm(self, use_new_cursor=False, company_id=False):
        """ Create procurements based on orderpoints.
        :param bool use_new_cursor: if set, use a dedicated cursor and auto-commit after processing
            1000 orderpoints.
            This is appropriate for batch jobs only.
        """
        if company_id and self.env.user.company_id.id != company_id:
            # To ensure that the company_id is taken into account for
            # all the processes triggered by this method
            # i.e. If a PO is generated by the run of the procurements the
            # sequence to use is the one for the specified company not the
            # one of the user's company
            self = self.with_context(company_id=company_id, force_company=company_id)

        OrderPoint = self.env['stock.warehouse.orderpoint']
        domain = self._get_orderpoint_domain(company_id=company_id)
        orderpoints_noprefetch = OrderPoint.with_context(prefetch_fields=False).search(domain,
            order=self._procurement_from_orderpoint_get_order()).ids
        picking_location = {}
        while orderpoints_noprefetch:
            if use_new_cursor:
                cr = registry(self._cr.dbname).cursor()
                self = self.with_env(self.env(cr=cr))
            OrderPoint = self.env['stock.warehouse.orderpoint']
            Procurement = self.env['procurement.order']
            ProcurementAutorundefer = Procurement.with_context(procurement_autorun_defer=True)
            procurement_list = []

            orderpoints = OrderPoint.browse(orderpoints_noprefetch[:1000])
            orderpoints_noprefetch = orderpoints_noprefetch[1000:]
            
            StockPicking = self.env['stock.picking']

            # Calculate groups that can be executed together
            location_data = defaultdict(lambda: dict(products=self.env['product.product'], orderpoints=self.env['stock.warehouse.orderpoint'], groups=list()))
            for orderpoint in orderpoints:
                warehouse_id = self.env['stock.warehouse'].search([('main_warehouse', '=', True), ('company_id','=',orderpoint.company_id.id)], limit=1)
                if warehouse_id:
                    if orderpoint.warehouse_id.main_warehouse:
                        key = self._procurement_from_orderpoint_get_grouping_key([orderpoint.id])
                        location_data[key]['products'] += orderpoint.product_id
                        location_data[key]['orderpoints'] += orderpoint
                        location_data[key]['groups'] = self._procurement_from_orderpoint_get_groups([orderpoint.id])
                    else:
                        location_dest_id = orderpoint.location_id.id
                        picking_type_id = warehouse_id.int_type_id
                        qty = 0.0
                        stock_quot=self.env['stock.quant'].search([('location_id','=',orderpoint.location_id.id),('product_id','=',orderpoint.product_id.id)])
                        for qt in stock_quot:
                            qty += qt.qty
                        picking_draft_ids=StockPicking.search([('state','=','draft'),('picking_type_id','=',picking_type_id.id)])
                        for picking_id in picking_draft_ids:
                            for move in picking_id.move_lines:
                                if move.product_id.id == orderpoint.product_id.id:
                                    qty += move.product_uom_qty 
                        if qty<orderpoint.product_max_qty:
                            update_qty = 0.0
                            if qty < 0:
                                update_qty =orderpoint.product_max_qty + (qty*-1) 
                            else:
                                update_qty = orderpoint.product_max_qty - qty 
                            if qty <= orderpoint.product_min_qty:
                                if not picking_location.get('order_id', {}).get(orderpoint.warehouse_id.id):
                                    value = {}
                                    value['location_dest_id']=location_dest_id
                                    value['move_type']='direct'
                                    value['picking_type_id']=picking_type_id.id
                                    value['location_id']=picking_type_id.default_location_src_id.id
                                    #value['origin']=orderpoint.name
                                    value['move_lines'] = [(0, None, {
                                                  'product_id':orderpoint.product_id.id,
                                                  'location_id':picking_type_id.default_location_src_id.id,
                                                  'location_dest_id':location_dest_id,
                                                  'origin':orderpoint.name,
                                                  'product_uom_qty':update_qty,
                                                  'product_uom':orderpoint.product_id.uom_id.id,
                                                  'name':orderpoint.product_id.name,
                                                  'stock_on_hand':orderpoint.product_id.qty_available,
                                                  })]
                                    picking_id = StockPicking.create(value)
                                    picking_location['order_id']= {orderpoint.warehouse_id.id: picking_id.id}
                                else:
                                    picking_id = picking_location.get('order_id', {}).get(orderpoint.warehouse_id.id)
                                    #picking = StockPicking.browse(picking_id)
                                    value = {
                                              'picking_id':picking_id,
                                              'product_id':orderpoint.product_id.id,
                                              'location_id':picking_type_id.default_location_src_id.id,
                                              'location_dest_id':location_dest_id,
                                              'origin':orderpoint.name,
                                              'product_uom_qty':update_qty,
                                              'product_uom':orderpoint.product_id.uom_id.id,
                                              'name':orderpoint.product_id.name,
                                              'stock_on_hand':orderpoint.product_id.qty_available,
                                              }
                                    self.env['stock.move'].create(value)
                else:
                    key = self._procurement_from_orderpoint_get_grouping_key([orderpoint.id])
                    location_data[key]['products'] += orderpoint.product_id
                    location_data[key]['orderpoints'] += orderpoint
                    location_data[key]['groups'] = self._procurement_from_orderpoint_get_groups([orderpoint.id])        
                                
            for location_id, location_data in location_data.iteritems():
                location_orderpoints = location_data['orderpoints']
                product_context = dict(self._context, location=location_orderpoints[0].location_id.id)
                substract_quantity = location_orderpoints.subtract_procurements_from_orderpoints()

                for group in location_data['groups']:
                    if group.get('from_date'):
                        product_context['from_date'] = group['from_date'].strftime(DEFAULT_SERVER_DATETIME_FORMAT)
                    if group['to_date']:
                        product_context['to_date'] = group['to_date'].strftime(DEFAULT_SERVER_DATETIME_FORMAT)
                    product_quantity = location_data['products'].with_context(product_context)._product_available()
                    for orderpoint in location_orderpoints:
                        try:
                            op_product_virtual = product_quantity[orderpoint.product_id.id]['virtual_available']
                            if op_product_virtual is None:
                                continue
                            if float_compare(op_product_virtual, orderpoint.product_min_qty, precision_rounding=orderpoint.product_uom.rounding) <= 0:
                                qty = max(orderpoint.product_min_qty, orderpoint.product_max_qty) - op_product_virtual
                                remainder = orderpoint.qty_multiple > 0 and qty % orderpoint.qty_multiple or 0.0

                                if float_compare(remainder, 0.0, precision_rounding=orderpoint.product_uom.rounding) > 0:
                                    qty += orderpoint.qty_multiple - remainder

                                if float_compare(qty, 0.0, precision_rounding=orderpoint.product_uom.rounding) < 0:
                                    continue

                                qty -= substract_quantity[orderpoint.id]
                                qty_rounded = float_round(qty, precision_rounding=orderpoint.product_uom.rounding)
                                if qty_rounded > 0:
                                    new_procurement = ProcurementAutorundefer.create(
                                        orderpoint._prepare_procurement_values(qty_rounded, **group['procurement_values']))
                                    procurement_list.append(new_procurement)
                                    new_procurement.message_post_with_view('mail.message_origin_link',
                                        values={'self': new_procurement, 'origin': orderpoint},
                                        subtype_id=self.env.ref('mail.mt_note').id)
                                    self._procurement_from_orderpoint_post_process([orderpoint.id])
                                if use_new_cursor:
                                    cr.commit()

                        except OperationalError:
                            if use_new_cursor:
                                orderpoints_noprefetch += [orderpoint.id]
                                cr.rollback()
                                continue
                            else:
                                raise

            try:
                # TDE CLEANME: use record set ?
                procurement_list.reverse()
                procurements = self.env['procurement.order']
                for p in procurement_list:
                    procurements += p
                procurements.run()
                if use_new_cursor:
                    cr.commit()
            except OperationalError:
                if use_new_cursor:
                    cr.rollback()
                    continue
                else:
                    raise

            if use_new_cursor:
                cr.commit()
                cr.close()

        return {}